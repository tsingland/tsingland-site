---
title: "C++"
date: 2019-08-16T18:10:57+08:00
draft: true
---
  #### 虚析构函数

+ 为了正确调用析构函数， 将层次结构的顶级类中的析构函数为虚函数
    ```
    lass Base(){
        Base();
        virtual ~Base();

    }

    class Drived() public Base(){ Drived(); ~Drived();
    }

    int main(){
        Base * base;
        base = new Drived();
        delete base;

    }
    ```
+ 使用virtual会发生动态绑定

    析构的时候先执行析构派生类的析构函数，再执行基类的析构函数

+ 不使用virtual将是静态绑定

    使用delete base 的时候只是调用Base类的析构函数

**C++的动态绑定**

#### POD类型
+ 说明
    同一个便一单元内是明确的， 静态初始化优先于动态初始化， 初始化顺序是按照声明的顺序进行，销毁则是逆序。不同编译单元之间初始化和销毁顺序属于未明确的行为（unspcified behaviour）


#### class 类型的使用
+ 说明
    多线程中全局变量（含有静态成员变量）不要使用class类型（含有STL容器），避免不明确行为导致的bug

#### 局部变量初始化
+ 说明
    局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值高效的多。

#### 在构造函数中调用了自身的虚函数
+ 说明
    这类调用不会重定向到子类的虚函数实现。

#### 不要定义隐式类型转换
+ 说明
    explicit 关键字可以用于构造函数（C++11引入）类型转换运算符。

#### 结构体 VS 类
+ 说明
    仅当只有数据成员的时候使用struct，其他一概使用class；


#### 什么时候把头文件放到 header中，什么时候放到source文件中
+ header中

    如果此头文件需要被其他头文件包含；

+ source中

    如果此头文件只是被此文件使用，那么就没必要放到header中，只包含在此source文件中即可。否则会增加编译时间；

#### c++ 类中的枚举类型

	c++ 中可以使用类名访问枚举值。

	1、为什么可以通过 类名::enum 值访问枚举值？

	因为该枚举值为常量，在编译的时候已经编译进常量区，因此在调用的时候也可以不使用枚举变量调用该枚举值；


###FRQ

#### 为什么 int 类型作为函数的参数的时候不用传入 cons int & 类型

	传引用主要是为了防止不必要的拷贝带来的开销，指针类型和int 类型占用的大小是一致的。

#### QString &类型作为返回参数的时候不传入 应用只是传入 QString* a 类型呢？

	约定成俗的习惯（seafile-client 是这样）
